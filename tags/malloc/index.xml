<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Malloc on Bits and Pieces</title>
    <link>https://tarangranpara.github.io/tags/malloc/</link>
    <description>Recent content in Malloc on Bits and Pieces</description>
    <generator>Hugo -- 0.125.7</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Sep 2025 16:22:06 +0530</lastBuildDate>
    <atom:link href="https://tarangranpara.github.io/tags/malloc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reinventing malloc: The First-Principles Journey, Part I</title>
      <link>https://tarangranpara.github.io/Posts/malloc_internals/</link>
      <pubDate>Sat, 13 Sep 2025 16:22:06 +0530</pubDate>
      <guid>https://tarangranpara.github.io/Posts/malloc_internals/</guid>
      <description>Introduction When you call malloc in C, it just… hands you memory. But how? Where does that memory actually come from? And why do we even need a function like malloc in the first place?
To answer that, let’s build our own allocator from scratch. We’ll start from first principles: understand what dynamic memory allocation is, examine the constructs the operating system provides for it, identify which ones can help us reinvent malloc, and eventually settle on sbrk as our tool of choice.</description>
    </item>
  </channel>
</rss>
